## Special Permissions & Access Control Lists

**Special Permissions**

Beyond the standard read (r), write (w), and execute (x) permissions, Linux provides three special permissions that modify the behavior of files and directories:

  - SUID (Set User ID) - Runs executable as file owner
  - SGID (Set Group ID) - Runs executable as group owner / Inherits directory group
  - Sticky Bit - Restricts deletion in shared directories

- Permissions Overview:

| Permission | Name | Octal | Symbolic | Applied To | Effect |
|------------|------|-------|----------|------------|--------|
| **SUID** | Set User ID | 4 | `s` (user x position) | Executable files | Execute as file owner |
| **SGID** | Set Group ID | 2 | `s` (group x position) | Executables & Directories | Execute as group owner / Inherit group |
| **Sticky Bit** | Restricted Deletion | 1 | `t` (others x position) | Directories | Only owner can delete files |


- Permission Format with Special Bits
  - Permission Format
    - Full Octal Format:
        `[Special][User][Group][Other]`
      
  - Visual Representation
```
┌─────────────────────────────────────────────────┐
│  Permission String Format (10 characters)       │
├─────────────────────────────────────────────────┤
│                                                 │
│  - rwx rwx rwx                                  │
│  │ │││ │││ │││                                  │
│  │ │││ │││ ││└─ Others:  Execute                │
│  │ │││ │││ │└── Others: Write                   │
│  │ │││ │││ └─── Others: Read                    │
│  │ │││ ││└───── Group: Execute                  │
│  │ │││ │└────── Group: Write                    │
│  │ │││ └─────── Group: Read                     │
│  │ ││└───────── Owner: Execute                  │
│  │ │└────────── Owner: Write                    │
│  │ └─────────── Owner: Read                     │
│  └───────────── File Type                       │
│                                                 │
│  WITH SPECIAL PERMISSIONS:                      │
│  - rws rwx rwx  (SUID:  s in owner execute)     │
│  - rwx rws rwx  (SGID: s in group execute)      │
│  - rwx rwx rwt  (Sticky: t in others execute)   │
│  - rwS rwx rwx  (SUID without execute:  S)      │
│  - rwx rwS rwx  (SGID without execute: S)       │
│  - rwx rwx rwT  (Sticky without execute: T)     │
│                                                 │
└─────────────────────────────────────────────────┘
```
  - SUID (Set User ID) - Octal 4

What is SUID?
- SUID allows a user to execute a file with the permissions of the file's owner (not the user running it).
- Allow regular users to execute commands that require elevated privileges (typically root).

- How SUID Works?
```
┌─────────────────────────────────────────────────┐
│  SUID Execution Flow                            │
├─────────────────────────────────────────────────┤
│                                                 │
│  Normal Execution:                              │
│  User "john" → runs program → executes as john  │
│                                                 │
│  SUID Execution:                                │
│  User "john" → runs SUID program → executes     │
│                as file owner (e.g., root)       │
│                                                 │
│  Example:  /usr/bin/passwd                      │
│  - Owner: root                                  │
│  - Permission: -rwsr-xr-x (4755)                │
│  - Any user runs it → executes as root          │
│  - Allows changing password (updates /etc/shadow)│
│                                                 │
└─────────────────────────────────────────────────┘
```

- SUID Representation

- Symbolic:
  - Lowercase `s`: Execute permission is set (`rws`) - WORKING
  - Uppercase `S`: Execute permission is NOT set (`rwS`) - INEFFECTIVE!

Octal:
  - Add `4` to the beginning of the standard permission, Runs as owner.
  - Example: `4755` = SUID + rwxr-xr-x

- SUID Examples

```bash
find / -perm -4000 -type f 2>/dev/null      # Find SUID files on the system

# Common SUID files
ls -l /usr/bin/passwd                        # -rwsr-xr-x 1 root root ...  /usr/bin/passwd

ls -l /usr/bin/sudo                          # -rwsr-xr-x 1 root root ...  /usr/bin/sudo

ls -l /usr/bin/su                             # -rwsr-xr-x 1 root root ...  /usr/bin/su

ls -l /bin/ping                               # -rwsr-xr-x 1 root root ...  /bin/ping

ls -l /usr/bin/mount                           # -rwsr-xr-x 1 root root ...  /usr/bin/mount

ls -l /usr/bin/umount                          # -rwsr-xr-x 1 root root ... /usr/bin/umount
```

- Why do these need SUID:
  - passwd: Needs to modify `/etc/shadow` (root only file)
  - sudo: Needs to execute commands as root
  - su:  Needs to switch user identity
  - ping: Needs to open raw network sockets (privileged operation)
  - mount/umount: Needs to modify system mount points


- Setting SUID Permission

  - Method 1: Symbolic
    - Create test script `vim /tmp/testscript.sh`
```bash
#!/bin/bash
echo "Running as:  $(whoami)"
echo "Real UID: $(id -ru)"
echo "Effective UID: $(id -u)"
id
```
```
chmod u+x /tmp/testscript.sh          # Make executable

chmod u+s /tmp/testscript.sh          # Set SUID bit


ls -l /tmp/testscript.sh               # Verify
```
  -  -rwsr-xr-x ...  testscript.sh


- Method 2: Numeric (Octal)
```bash
chmod 4755 /tmp/testscript.sh            # Set SUID with 4 prefix


ls -l /tmp/testscript.sh                  # Verify
```
  - -rwsr-xr-x ... testscript.sh

- Remove SUID
```bash
chmod u-s /tmp/testscript.sh          # Symbolic method

chmod 0755 /tmp/testscript.sh          # Numeric method
```

- SUID Warning Signs:
  - Uppercase `S` indicates a problem, for example:
```bash
chmod 4644 file
ls -l file
# -rwSr--r-- ...  file
```

- The `S` (uppercase) means: 
  - SUID bit is set
  - But execute permission is NOT set
  - Result:  SUID is INEFFECTIVE

- Fix it:
```bash
chmod 4755 file
ls -l file
```
  - -rwsr-xr-x ... file (lowercase s = working)


- Security Implications of SUID
```
┌─────────────────────────────────────────────────┐
│  SUID Security Risks                            │
├─────────────────────────────────────────────────┤
│                                                 │
│    SUID files are HIGH SECURITY RISK            │
│                                                 │
│  Risks:                                         │
│  • Privilege escalation vulnerabilities         │
│  • Attacker gains owner privileges              │
│  • Common target for exploits                   │
│                                                 │
│  Best Practices:                                │
│  ✓ Minimize SUID files on the system            │
│  ✓ Regularly audit SUID files                   │
│  ✓ NEVER set SUID on shell scripts              │
│  ✓ Only use on compiled binaries                │
│  ✓ Ensure proper input validation               │
│  ✓ Keep SUID binaries patched and updated       │
│                                                 │
│  Audit SUID files:                              │
│  find / -perm -4000 -ls 2>/dev/null             │
│                                                 │
└─────────────────────────────────────────────────┘
```

---

SGID (Set Group ID) - 

- What is SGID?
  - SGID runs as a group.
  - SGID has two different behaviors depending on whether it's applied to a file or a directory:
    - On executable files:
      - Execute with group permissions of the file (like SUID but for the group)
    - On directories:
      - New files inherit the directory's group (not the creator's group)

- SGID on Executable Files
```
┌─────────────────────────────────────────────────┐
│  SGID on Executables                            │
├─────────────────────────────────────────────────┤
│                                                 │
│  Normal Execution:                              │
│  User runs program → executes with user's group │
│                                                 │
│  SGID Execution:                                │
│  User runs SGID program → executes with file's  │
│  group permissions (not the user's group)       │
│                                                 │
│  Example: /usr/bin/wall                         │
│  - Group: tty                                   │
│  - Permission: -rwxr-sr-x (2755)                │
│  - Any user runs it → executes as 'tty' group   │
│  - Allows writing to terminals                  │
│                                                 │
└─────────────────────────────────────────────────┘
```

- SGID on Directories (More Common Use)
  - Primary Use Case: Shared project directories where all files should belong to a common group. 

```
┌─────────────────────────────────────────────────┐
│  SGID on Directories                            │
├─────────────────────────────────────────────────┤
│                                                 │
│  Without SGID:                                  │
│  User creates file → file group = user's        │
│                       primary group             │
│                                                 │
│  With SGID:                                     │
│  User creates file → file group = directory's   │
│                       group (inherited)         │
│                                                 │
│  Benefit: All team members can collaborate      │
│           with consistent group ownership       │
│                                                 │
└─────────────────────────────────────────────────┘
```

- SGID Representation
  - Symbolic:
    - Lowercase `s`: Execute permission is set (`r-s` or `rws`) - **WORKING**
    - Uppercase `S`: Execute permission is NOT set (`r-S`) - **PROBLEMATIC!**

- Octal:
  - Add `2` to the beginning of the standard permission
  - Example: `2775` = SGID + rwxrwxr-x


- SGID Examples
  - Example 1: Find SGID Files
```bash
find / -perm -2000 -type f 2>/dev/null            # Find all SGID files

find / -perm -2000 -type d 2>/dev/null            # Find all SGID directories

ls -l /usr/bin/plocate                               # Common SGID files

ls -l /usr/bin/write
```
<img width="743" height="377" alt="Screenshot 2025-12-18 at 1 02 28 PM" src="https://github.com/user-attachments/assets/4643ea02-e066-44e8-9914-5dbe169f91b0" />


- Example 2: SGID on Directory (Practical Use Case)
  - Scenario: Create a shared project directory for the team

```bash
# Create project directory
sudo mkdir /projects/team_alpha

# Create project group
sudo groupadd developers

# Add users to group
sudo usermod -aG developers alice
sudo usermod -aG developers bob
sudo usermod -aG developers charlie

# Set directory ownership
sudo chown root:developers /projects/team_alpha

# Set SGID permission
sudo chmod 2775 /projects/team_alpha

# Verify
ls -ld /projects/team_alpha
# drwxrwsr-x 2 root developers ...  /projects/team_alpha
#       ^
#       SGID bit (s in group execute position)
```

- Test SGID behavior:
```bash
# Alice creates a file
su - alice
cd /projects/team_alpha
touch alice_document.txt
ls -l alice_document.txt
# -rw-rw-r-- 1 alice developers ... alice_document. txt
#                     ^^^^^^^^^^
#                     Group inherited from directory! 

# Without SGID, it would be: 
# -rw-rw-r-- 1 alice alice ...  alice_document.txt

# Bob can now access Alice's file (same group)
su - bob
cd /projects/team_alpha
vim alice_document.txt  # Can edit (group write permission)
```

- Setting SGID Permission

- Method 1: Symbolic
```bash
# On file
chmod g+s /path/to/executable

# On directory
chmod g+s /path/to/directory
```

- Method 2: Numeric (Octal)
```bash
# SGID + rwxrwxr-x
chmod 2775 /path/to/directory

# SGID + rwxr-xr-x
chmod 2755 /path/to/file
```

- Remove SGID
```bash
# Symbolic method
chmod g-s /path/to/file

# Numeric method
chmod 0775 /path/to/directory
```

- MORE SGID Examples

- Example 3: Complete SGID Directory Setup

```bash
# Create shared directory for marketing team
sudo mkdir /shared/marketing
sudo groupadd marketing
sudo usermod -aG marketing john
sudo usermod -aG marketing jane
sudo usermod -aG marketing jack

# Set ownership and SGID
sudo chown root: marketing /shared/marketing
sudo chmod 2770 /shared/marketing

# Verify
ls -ld /shared/marketing
# drwxrws--- 2 root marketing ... /shared/marketing

# John creates subdirectory
su - john
cd /shared/marketing
mkdir campaign2024
ls -ld campaign2024
# drwxrwsr-x 2 john marketing ... campaign2024
#       ^                        ^
#       SGID inherited           Group inherited

# Jane creates file in John's directory
su - jane
cd /shared/marketing/campaign2024
touch proposal. doc
ls -l proposal.doc
# -rw-rw-r-- 1 jane marketing ...  proposal.doc

# Jack can also collaborate
su - jack
cd /shared/marketing/campaign2024
echo "Budget: $50,000" >> proposal.doc  # Success!
```


- Example 4: SGID Without Execute (Uppercase S)
```bash
# Create file
touch testfile

# Set SGID without execute
chmod 2644 testfile

# Check result
ls -l testfile
# -rw-r-Sr-- ...  testfile
#       ^
#       Uppercase S = SGID set but no execute! 

# This is ineffective - fix it
chmod 2755 testfile
ls -l testfile
# -rwxr-sr-x ... testfile (lowercase s = working)
```

- Example 5: Multi-Level SGID Directory Structure
```bash
# Create project structure
sudo mkdir -p /data/projects/{alpha,beta,gamma}
sudo groupadd project_team

# Set SGID recursively
sudo chown -R root:project_team /data/projects
sudo chmod -R 2775 /data/projects

# Verify all directories have SGID
find /data/projects -type d -exec ls -ld {} \;
# drwxrwsr-x ...  /data/projects
# drwxrwsr-x ... /data/projects/alpha
# drwxrwsr-x ... /data/projects/beta
# drwxrwsr-x ... /data/projects/gamma

# Any user in project_team creates files
su - alice
cd /data/projects/alpha
mkdir docs
touch docs/notes.txt

# All inherit project_team group
ls -lR /data/projects/alpha
# drwxrwsr-x ...  docs
# -rw-rw-r-- ... docs/notes.txt
```

- Example 6: SGID with umask for Consistent Permissions
```bash
# Set umask for group collaboration
umask 002

# Create SGID directory
sudo mkdir /workspace/shared
sudo chgrp developers /workspace/shared
sudo chmod 2775 /workspace/shared

# Create files
cd /workspace/shared
touch file1.txt
mkdir subdir

# Check permissions
ls -l
# -rw-rw-r-- ...  file1.txt  (664 from umask 002)
# drwxrwsr-x ... subdir      (775 from umask 002 + SGID)
```

---

Sticky Bit - Octal 1

- What is Sticky Bit?
  - Sticky Bit is applied to directories to restrict file deletion. When set: 
    - Only the file owner, directory owner, or root can delete files
    - Other users with write permission cannot delete files they don't own
  - Shared directories like `/tmp` where multiple users can create files, but shouldn't delete each other's files.

- How Sticky Bit Works
```
┌─────────────────────────────────────────────────┐
│  Sticky Bit Behavior                            │
├─────────────────────────────────────────────────┤
│                                                 │
│  Without Sticky Bit:                            │
│  Directory:  drwxrwxrwx (777)                   │
│  Any user can:                                  │
│    ✓ Create files                               │
│    ✓ Delete ANY file (even files owned by       │
│      others)                                    │
│                                                 │
│  With Sticky Bit:                               │
│  Directory: drwxrwxrwt (1777)                   │
│  Users can:                                     │
│    ✓ Create files                               │
│    ✓ Delete ONLY their own files                │
│    ✗ Cannot delete files owned by others        │
│                                                 │
│  Real world example: /tmp                       │
│  - Everyone can create temp files               │
│  - Nobody can delete others' temp files         │
│  - Prevents malicious deletion                  │
│                                                 │
└─────────────────────────────────────────────────┘
```


- Sticky Bit Representation
  - Symbolic:
    - Lowercase `t`: Execute permission is set for others (`rwt`) - **WORKING**
    - Uppercase `T`: Execute permission is NOT set for others (`rwT`)

- Octal:
  - Add `1` to the beginning of standard permission, which prevents deletion in shared directories.
  - Example: `1777` = Sticky + rwxrwxrwx


- Sticky Bit Examples
- 
- Example 1: /tmp Directory
```bash
# Check /tmp directory
ls -ld /tmp
# drwxrwxrwt 20 root root ... /tmp
#         ^
#         Sticky bit

# Octal representation:  1777
stat -c "%a %n" /tmp
# 1777 /tmp
```

- Example 2: Testing Sticky Bit Behavior
  - Without Sticky Bit:
```bash
# Create test directory
sudo mkdir /shared/no_sticky
sudo chmod 777 /shared/no_sticky

# User alice creates file
su - alice
cd /shared/no_sticky
touch alice_file.txt
ls -l alice_file.txt
# -rw-rw-r-- 1 alice alice ... alice_file.txt
exit

# User bob can delete alice's file! 
su - bob
cd /shared/no_sticky
rm alice_file.txt  # SUCCESS - File deleted!
```

- With Sticky Bit:
```bash
# Create test directory with sticky bit
sudo mkdir /shared/with_sticky
sudo chmod 1777 /shared/with_sticky

# Verify sticky bit
ls -ld /shared/with_sticky
# drwxrwxrwt 2 root root ... /shared/with_sticky

# User alice creates file
su - alice
cd /shared/with_sticky
touch alice_file.txt
exit

# User bob tries to delete alice's file
su - bob
cd /shared/with_sticky
rm alice_file.txt
# rm: cannot remove 'alice_file.txt': Operation not permitted

# Bob can delete his own files
touch bob_file.txt
rm bob_file.txt  # SUCCESS

# Alice can delete her own file
su - alice
cd /shared/with_sticky
rm alice_file. txt  # SUCCESS
```

- Setting Sticky Bit
  - Method 1: Symbolic
```bash
# Set sticky bit
chmod +t /path/to/directory

# Or explicitly for others
chmod o+t /path/to/directory
```

- Method 2: Numeric (Octal)
```bash
# Sticky + rwxrwxrwx
chmod 1777 /path/to/directory

# Sticky + rwxrwxr-x
chmod 1775 /path/to/directory
```

- Remove Sticky Bit
```bash
# Symbolic method
chmod -t /path/to/directory

# Numeric method
chmod 0777 /path/to/directory
```

- MORE Sticky Bit Examples

- Example 3: Shared Upload Directory
```bash
# Create upload directory
sudo mkdir /var/uploads
sudo chmod 1777 /var/uploads

ls -ld /var/uploads
# drwxrwxrwt 2 root root ...  /var/uploads

# Users can upload but not delete others' files
su - alice
cd /var/uploads
echo "Alice's data" > data_alice.csv
exit

su - bob
cd /var/uploads
echo "Bob's data" > data_bob.csv

# Bob cannot delete Alice's file
rm data_alice.csv
# rm: cannot remove 'data_alice.csv': Operation not permitted

# Bob can delete his own
rm data_bob.csv  # Success
```

- Example 4: Multi User Temp Directory
```bash
# Create application temp directory
sudo mkdir /app/temp
sudo chmod 1777 /app/temp

# All users can create temp files
# Users can only clean up their own files

# Test with multiple users
su - user1
cd /app/temp
touch user1_temp_123.tmp
exit

su - user2
cd /app/temp
touch user2_temp_456.tmp

# user2 cannot delete user1's temp file
rm user1_temp_123.tmp
# rm: cannot remove 'user1_temp_123.tmp': Operation not permitted
```

- Example 5: Shared Drop Box (Write Only Directory)
```bash
# Create drop box for document submission
sudo mkdir /shared/dropbox
sudo chmod 1733 /shared/dropbox  # write + execute + sticky

ls -ld /shared/dropbox
# d-wx-wx-wt 2 root root ... /shared/dropbox

# Users can add files but cannot list or delete others' files
su - student1
cd /shared/dropbox
echo "Assignment submission" > assignment_student1.txt
ls  # Permission denied (no read permission)
exit

su - student2
cd /shared/dropbox
echo "Assignment submission" > assignment_student2.txt
rm assignment_student1.txt  # Operation not permitted (sticky bit)
```

- Example 6: Sticky Bit on Uppercase T
```bash
# Create directory
mkdir testdir

# Set sticky without executing for others
chmod 1776 testdir

ls -ld testdir
# drwxrwxrwT ...  testdir
#         ^
#         Uppercase T = sticky set but no execute for others

# Others cannot cd into the directory
su - otheruser
cd testdir  # Permission denied

# Fix by adding execute
chmod 1777 testdir
ls -ld testdir
# drwxrwxrwt ... testdir (lowercase t = working)
```

- Example 7: Comparing Sticky vs No Sticky
```bash
# Setup two directories
sudo mkdir /test/{sticky,nosticky}
sudo chmod 777 /test/nosticky
sudo chmod 1777 /test/sticky

# Test without sticky
su - alice
touch /test/nosticky/alice_file
exit

su - bob
rm /test/nosticky/alice_file  # Success - PROBLEM!

# Test with sticky
su - alice
touch /test/sticky/alice_file
exit

su - bob
rm /test/sticky/alice_file  # Operation not permitted - PROTECTED!
```

---

Combining Special Permissions
  - You can combine special permissions by adding their octal values:

| Combination | Octal | Description |
|-------------|-------|-------------|
| SUID only | 4### | Set user ID |
| SGID only | 2### | Set group ID |
| Sticky only | 1### | Restricted deletion |
| SUID + SGID | 6### | Both user and group ID |
| SUID + Sticky | 5### | User ID + restricted deletion |
| SGID + Sticky | 3### | Group ID + restricted deletion |
| All three | 7### | All special permissions |


- Examples of Combined Permissions
```bash
# SUID + SGID (rarely used)
chmod 6755 /path/to/file
ls -l /path/to/file
# -rwsr-sr-x ...  file

# SGID + Sticky (common for shared directories)
chmod 3770 /path/to/directory
ls -ld /path/to/directory
# drwxrws--T ... directory

# All three special permissions (very rare)
chmod 7755 /path/to/file
ls -l /path/to/file
# -rwsr-sr-t ... file
```

- Practical Combined Example
  - Scenario: Shared project directory with group inheritance and deletion protection
```bash
# Create project directory
sudo mkdir /projects/secure_team

# Create group
sudo groupadd projectteam
sudo usermod -aG projectteam alice
sudo usermod -aG projectteam bob

# Set ownership
sudo chown root:projectteam /projects/secure_team

# Set SGID + Sticky bit (octal 3)
sudo chmod 3770 /projects/secure_team

# Verify
ls -ld /projects/secure_team
# drwxrws--T 2 root projectteam ... /projects/secure_team
#       ^ ^
#       │ └─ Sticky bit (T = no execute for others, but sticky set)
#       └─── SGID bit

# Test behavior
su - alice
cd /projects/secure_team
touch report.txt
ls -l report.txt
# -rw-rw-r-- 1 alice projectteam ... report.txt
#                    ^^^^^^^^^^^
#                    Group inherited from directory (SGID)

# Bob tries to delete Alice's file
su - bob
cd /projects/secure_team
rm report.txt
# rm: cannot remove 'report.txt': Operation not permitted
#                                  (Sticky bit protection)
```

- MORE Combined Permission Examples

- Example 1: SGID + Sticky for Collaborative Workspace
```bash
# Create workspace
sudo mkdir /workspace/collaboration
sudo groupadd collab_team
sudo usermod -aG collab_team alice bob charlie

# Set combined permissions
sudo chown root:collab_team /workspace/collaboration
sudo chmod 3775 /workspace/collaboration

# Verify
ls -ld /workspace/collaboration
# drwxrwsr-t ... /workspace/collaboration

# Benefits:
# 1. SGID: All files inherit the collab_team group
# 2. Sticky: Users can't delete each other's files
# 3. 775: Group members have full access

# Test
su - alice
cd /workspace/collaboration
mkdir project_docs
touch project_docs/readme.md

su - bob
cd /workspace/collaboration
# Can modify Alice's files (same group)
echo "Updates" >> project_docs/readme.md  # Success

# Cannot delete Alice's directory
rm -rf project_docs  # Operation not permitted
```

- Example 2: All Three Special Permissions (Educational)
```bash
# Create test file (rarely practical)
sudo touch /tmp/test_all_special
sudo chmod 7755 /tmp/test_all_special
sudo chown root:root /tmp/test_all_special

# Verify
ls -l /tmp/test_all_special
# -rwsr-sr-t 1 root root ... /tmp/test_all_special
#    ^  ^  ^
#    │  │  └─ Sticky bit
#    │  └──── SGID
#    └─────── SUID

# This is impractical and not recommended
```

---

## Introduction to ACLs (Access Control Lists)

- What are ACLs?
  - Access Control Lists (ACLs) provide more fine grained permission control than traditional Linux permissions. They allow you to grant permissions to **specific users and groups** beyond the standard owner/group/others model.

- Why Use ACLs?
  - Traditional Permissions Limitation:
```
-rwxrw-r-- 1 alice developers project. txt

• Owner (alice): rwx
• Group (developers): rw
• Others: r

   Problem: How to give user "bob" write access
   without giving ALL users write access?
```

- ACL Solution:
```
-rwxrw-r--+ 1 alice developers project. txt
           ^
           + indicates ACL is set

✓ Can specifically grant Bob write access
✓ Other users still have only read access
```

- ACL Components
```
┌─────────────────────────────────────────────────┐
│  ACL Entry Format                               │
├─────────────────────────────────────────────────┤
│                                                 │
│  type: qualifier: permissions                   │
│                                                 │
│  Types:                                         │
│  u or user    - User ACL entry                  │
│  g or group   - Group ACL entry                 │
│  o or other   - Others entry                    │
│  m or mask    - Maximum permissions mask        │
│                                                 │
│  Qualifier:                                     │
│  username or UID   (for user entries)           │
│  groupname or GID  (for group entries)          │
│  (empty for owner/other)                        │
│                                                 │
│  Permissions:  r, w, x (same as traditional)    │
│                                                 │
└─────────────────────────────────────────────────┘
```

---

- ACL Commands:  getfacl and setfacl

- Checking Filesystem ACL Support

```bash
# Check if the filesystem supports ACLs
mount | grep $(df .  | tail -1 | awk '{print $1}')
# Look for 'acl' in mount options

# If not present, remount with ACL support
sudo mount -o remount,acl /

# Or add to /etc/fstab for permanent support
# Add 'acl' to options column
sudo vim /etc/fstab
# UUID=... / ext4 defaults,acl 0 1

# Verify ACL support
tune2fs -l /dev/sda1 | grep "Default mount options"
# Should show "acl"
```

- getfacl - Viewing ACLs
  - Syntax:
```bash
getfacl [options] filename
```

- Common Options:

| Option | Description |
|--------|-------------|
| `-c` | Concise output (no header comments) |
| `-d` | Display default ACL |
| `-R` | Recursive (show ACLs for directory contents) |
| `-n` | Show numeric UID/GID instead of names |
| `-t` | Tabular output format |

- Examples:

```bash
# View ACL of a file
getfacl file.txt

# Sample output:
# # file: file.txt
# # owner: alice
# # group:  developers
# user::rwx
# user:bob:rw-
# group::r--
# mask::rw-
# other::r--

# Concise output (no comments)
getfacl -c file.txt
# user::rwx
# user:bob:rw-
# group:: r--
# mask::rw-
# other::r--

# View ACL recursively
getfacl -R /project/

# View numeric UIDs/GIDs
getfacl -n file.txt

# View default ACL of directory
getfacl -d /shared/project/
```

- setfacl - Setting ACLs
  - Syntax:
```bash
setfacl [options] specification filename
```

- Common Options:

| Option | Description |
|--------|-------------|
| `-m` | Modify ACL (add or change entry) |
| `-x` | Remove specific ACL entry |
| `-b` | Remove all ACL entries |
| `-k` | Remove default ACL |
| `-R` | Recursive operation |
| `-d` | Set default ACL (for directories) |
| `--set` | Replace entire ACL |


- Examples:
```bash
# Grant user bob read and write access
setfacl -m u:bob:rw file.txt

# Grant group editors read access
setfacl -m g:editors:r file. txt

# Grant user execute permission
setfacl -m u:alice:rwx script.sh

# Multiple entries at once
setfacl -m u:bob:rw,g:editors:r,u:charlie:r file.txt

# Remove specific user entry
setfacl -x u:bob file.txt

# Remove specific group entry
setfacl -x g:editors file.txt

# Remove all ACLs (return to standard permissions)
setfacl -b file.txt

# Set recursively on directory
setfacl -R -m u:bob:rwx /project/

# Set default ACL on directory (inherited by new files)
setfacl -d -m u:bob:rw /project/

# Copy ACL from one file to another
getfacl file1.txt | setfacl --set-file=- file2.txt
```

---

- ACL Practical Examples

- Example 1: Granting Individual User Access
  - Scenario: Alice owns a file, but needs to give Bob write access without changing group permissions.

```bash
# Create file
touch project.txt
ls -l project.txt
# -rw-rw-r-- 1 alice alice project.txt

# Give Bob write access
setfacl -m u:bob:rw project.txt

# Verify
getfacl project. txt
# # file: project.txt
# # owner: alice
# # group:  alice
# user::rw-
# user:bob:rw-         <-- Bob has write access
# group::rw-
# mask::rw-
# other::r--

# Check with ls -l
ls -l project.txt
# -rw-rw-r--+ 1 alice alice project. txt
#          ^
#          + indicates ACL is set

# Bob can now edit the file
su - bob
echo "Bob's contribution" >> project.txt  # Success
```

- Example 2: Multiple Users with Different Permissions
  - Scenario: Give different permissions to multiple users on the same file.

```bash
# Create document
echo "Confidential data" > document.txt

# Set different permissions
setfacl -m u:alice:rwx document.txt  # Alice:  full access
setfacl -m u:bob:rw document. txt     # Bob: read/write
setfacl -m u: charlie:r document.txt  # Charlie: read only
setfacl -m u:david:--- document.txt  # David: no access

# Verify
getfacl document. txt
# user::rw-
# user:alice: rwx
# user:bob: rw-
# user:charlie:r--
# user:david:---
# group::rw-
# mask::rwx
# other::r--

# Test permissions
su - charlie
cat document.txt  # Success (read)
echo "edit" >> document.txt  # Permission denied

su - bob
echo "Bob's edit" >> document.txt  # Success (write)
```

- Example 3: Default ACLs for Directories
  - Scenario: Ensure all new files in a directory inherit specific ACLs.
```bash
# Create shared directory
mkdir /shared/project
chmod 770 /shared/project

# Set default ACL (inherited by new files)
setfacl -d -m u:bob:rw /shared/project
setfacl -d -m u:charlie:r /shared/project

# View default ACL
getfacl /shared/project
# # file: /shared/project
# # owner: root
# # group: root
# user::rwx
# group::rwx
# other::---
# default:user::rwx
# default:user:bob:rw-      <-- Default for new files
# default:user:charlie:r--  <-- Default for new files
# default:group::rwx
# default:mask::rwx
# default:other::---

# Create new file in directory
cd /shared/project
touch newfile.txt

# Check ACL of new file
getfacl newfile.txt
# user::rw-
# user:bob: rw-        <-- Inherited! 
# user:charlie:r--    <-- Inherited!
# group::rwx
# mask::rwx
# other::---
```

- Example 4: Group Based ACLs
  - Scenario: Grant access to multiple groups.
```bash
# Create file
touch report.pdf

# Grant different groups different permissions
setfacl -m g:managers:rw report.pdf
setfacl -m g:employees:r report.pdf
setfacl -m g: auditors:r report.pdf

# Verify
getfacl report.pdf
# user::rw-
# group::rw-
# group: managers:rw-
# group:employees:r--
# group:auditors:r--
# mask::rw-
# other:: r--
```

- Example 5: Recursive ACL Application
  - Scenario: Apply ACLs to the existing directory structure.

```bash
# Create directory structure
mkdir -p /data/project/{docs, code, tests}
touch /data/project/docs/readme.md
touch /data/project/code/main.py
touch /data/project/tests/test. sh

# Apply ACL recursively
setfacl -R -m u:bob:rwx /data/project

# Verify all files have ACL
getfacl -R /data/project | grep "user: bob"
# user: bob:rwx
# user: bob:rwx
# user:bob:rwx
# user:bob:rwx

# Also set default ACL for future files
setfacl -R -d -m u:bob: rwx /data/project
```

- Example 6: Removing ACLs

```bash
# Create file with ACLs
touch test.txt
setfacl -m u: bob:rw test.txt
setfacl -m u: alice:r test.txt

# View ACL
getfacl test.txt
# user::rw-
# user:bob:rw-
# user:alice: r--
# group::rw-
# mask::rw-
# other::r--

# Remove specific user ACL
setfacl -x u:bob test.txt

# Verify
getfacl test.txt
# user::rw-
# user:alice:r--    <-- Bob removed, Alice remains
# group::rw-
# mask:: r--
# other::r--

# Remove all ACLs
setfacl -b test.txt

# Verify (back to standard permissions)
ls -l test.txt
# -rw-rw-r-- 1 user user test.txt (no + sign)
```

- Example 7: ACL Mask
- Understanding the Mask:
  - The mask limits the maximum effective permissions for named users, named groups, and the owning group.
```bash
# Create file with ACLs
touch document.txt
setfacl -m u: bob:rwx document.txt

# Check ACL
getfacl document.txt
# user::rw-
# user:bob: rwx
# group::rw-
# mask::rwx      <-- Current mask
# other::r--

# Set restrictive mask
setfacl -m m:: r document.txt

# Check effective permissions
getfacl document. txt
# user::rw-
# user:bob:rwx   #effective: r--  <-- Limited by mask! 
# group::rw-     #effective:r--
# mask::r--
# other::r--

# Bob's actual permission is now r-- (read only)
# even though ACL says rwx
```

- Example 8: Copying ACLs Between Files
```bash
# Source file with ACLs
touch source.txt
setfacl -m u:bob:rw source.txt
setfacl -m u: alice:r source.txt
setfacl -m g:developers:rw source.txt

# Copy ACLs to another file
getfacl source.txt | setfacl --set-file=- target.txt

# Verify
getfacl target. txt
# Should match source.txt ACLs

# Alternative: Save ACL to file and restore later
getfacl source.txt > /tmp/acl_backup.txt
setfacl --set-file=/tmp/acl_backup.txt target.txt
```

- Example 9: ACLs for Web Server
  - Scenario: Web server needs access to user files.

```bash
# User creates website directory
mkdir ~/public_html
cd ~/public_html
touch index. html

# Give Apache/Nginx user read access
setfacl -m u:www-data:rx ~/public_html
setfacl -R -m u:www-data:r ~/public_html

# Set default ACL for new files
setfacl -d -m u:www-data:r ~/public_html

# Verify
getfacl ~/public_html
# user::rwx
# user:www-data:r-x
# group::r-x
# mask::r-x
# other:: r-x

# Test:  create new file
touch ~/public_html/newpage.html

getfacl ~/public_html/newpage.html
# user:: rw-
# user:www-data:r--  <-- Inherited from default ACL
# group::r--
# mask::r--
# other::r--
```

- Example 10: Backup and Restore ACLs
```bash
# Backup ACLs for entire directory
getfacl -R /data/project > /backup/project_acls.txt

# Later, restore ACLs
cd /data/project
setfacl --restore=/backup/project_acls.txt

# Backup ACLs with tar
tar -czpf /backup/project. tar.gz --acls /data/project

# Restore with ACLs
tar -xzpf /backup/project.tar.gz --acls
```

---
